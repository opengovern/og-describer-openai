// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	openai "github.com/opengovern/og-describer-openai/discovery/provider"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: File =============================

type File struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     openai.FileDescription `json:"Description"`
	Metadata        openai.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type FileHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  File          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FileHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FileHit         `json:"hits"`
}

type FileSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  FileHits `json:"hits"`
}

type FilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFilePaginator(filters []essdk.BoolFilter, limit *int64) (FilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_file", filters, limit)
	if err != nil {
		return FilePaginator{}, err
	}

	p := FilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FilePaginator) NextPage(ctx context.Context) ([]File, error) {
	var response FileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []File
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFileFilters = map[string]string{
	"bytes":     "Description.Bytes",
	"file_name": "Description.FileName",
	"id":        "Description.ID",
	"object":    "Description.Object",
	"purpose":   "Description.Purpose",
}

func ListFile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFile NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFile GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listFileFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFile NewFilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFileFilters = map[string]string{
	"bytes":     "Description.Bytes",
	"file_name": "Description.FileName",
	"id":        "Description.ID",
	"object":    "Description.Object",
	"purpose":   "Description.Purpose",
}

func GetFile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getFileFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: File =============================

// ==========================  START: Models =============================

type Models struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     openai.ModelsDescription `json:"Description"`
	Metadata        openai.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type ModelsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Models        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ModelsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ModelsHit       `json:"hits"`
}

type ModelsSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  ModelsHits `json:"hits"`
}

type ModelsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewModelsPaginator(filters []essdk.BoolFilter, limit *int64) (ModelsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_model", filters, limit)
	if err != nil {
		return ModelsPaginator{}, err
	}

	p := ModelsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ModelsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ModelsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ModelsPaginator) NextPage(ctx context.Context) ([]Models, error) {
	var response ModelsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Models
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listModelsFilters = map[string]string{
	"id":         "Description.ID",
	"object":     "Description.Object",
	"owned_by":   "Description.OwnedBy",
	"permission": "Description.Permission",
	"root":       "Description.Root",
}

func ListModels(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListModels")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListModels NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListModels NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListModels GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListModels GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListModels GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewModelsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listModelsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListModels NewModelsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListModels paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getModelsFilters = map[string]string{
	"id":         "Description.ID",
	"object":     "Description.Object",
	"owned_by":   "Description.OwnedBy",
	"permission": "Description.Permission",
	"root":       "Description.Root",
}

func GetModels(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetModels")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewModelsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getModelsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Models =============================

// ==========================  START: Assistant =============================

type Assistant struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     openai.AssistantDescription `json:"Description"`
	Metadata        openai.Metadata             `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type AssistantHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Assistant     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AssistantHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AssistantHit    `json:"hits"`
}

type AssistantSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  AssistantHits `json:"hits"`
}

type AssistantPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAssistantPaginator(filters []essdk.BoolFilter, limit *int64) (AssistantPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_assistant", filters, limit)
	if err != nil {
		return AssistantPaginator{}, err
	}

	p := AssistantPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AssistantPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AssistantPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AssistantPaginator) NextPage(ctx context.Context) ([]Assistant, error) {
	var response AssistantSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Assistant
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAssistantFilters = map[string]string{
	"description":    "Description.Description",
	"id":             "Description.ID",
	"instructions":   "Description.Instructions",
	"metadata":       "Description.Metadata",
	"model":          "Description.Model",
	"name":           "Description.Name",
	"temperature":    "Description.Temperature",
	"tool_resources": "Description.ToolResources",
	"tools":          "Description.Tools",
	"top_p":          "Description.TopP",
}

func ListAssistant(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAssistant")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAssistant NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAssistant NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAssistant GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAssistant GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAssistant GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAssistantPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAssistantFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAssistant NewAssistantPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAssistant paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAssistantFilters = map[string]string{
	"description":    "Description.Description",
	"id":             "Description.ID",
	"instructions":   "Description.Instructions",
	"metadata":       "Description.Metadata",
	"model":          "Description.Model",
	"name":           "Description.Name",
	"temperature":    "Description.Temperature",
	"tool_resources": "Description.ToolResources",
	"tools":          "Description.Tools",
	"top_p":          "Description.TopP",
}

func GetAssistant(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAssistant")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAssistantPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAssistantFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Assistant =============================

// ==========================  START: VectorStore =============================

type VectorStore struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     openai.VectorStoreDescription `json:"Description"`
	Metadata        openai.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type VectorStoreHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VectorStore   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VectorStoreHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VectorStoreHit  `json:"hits"`
}

type VectorStoreSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  VectorStoreHits `json:"hits"`
}

type VectorStorePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVectorStorePaginator(filters []essdk.BoolFilter, limit *int64) (VectorStorePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_vectorstore", filters, limit)
	if err != nil {
		return VectorStorePaginator{}, err
	}

	p := VectorStorePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VectorStorePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VectorStorePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VectorStorePaginator) NextPage(ctx context.Context) ([]VectorStore, error) {
	var response VectorStoreSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VectorStore
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVectorStoreFilters = map[string]string{
	"expires_after": "Description.ExpiresAfter",
	"file_counts":   "Description.FileCounts",
	"id":            "Description.ID",
	"metadata":      "Description.Metadata",
	"name":          "Description.Name",
	"object":        "Description.Object",
	"status":        "Description.Status",
	"usage_bytes":   "Description.UsageBytes",
}

func ListVectorStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVectorStore")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVectorStore NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVectorStore NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVectorStore GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVectorStore GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVectorStore GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVectorStorePaginator(essdk.BuildFilter(ctx, d.QueryContext, listVectorStoreFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVectorStore NewVectorStorePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVectorStore paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVectorStoreFilters = map[string]string{
	"expires_after": "Description.ExpiresAfter",
	"file_counts":   "Description.FileCounts",
	"id":            "Description.ID",
	"metadata":      "Description.Metadata",
	"name":          "Description.Name",
	"object":        "Description.Object",
	"status":        "Description.Status",
	"usage_bytes":   "Description.UsageBytes",
}

func GetVectorStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVectorStore")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVectorStorePaginator(essdk.BuildFilter(ctx, d.QueryContext, getVectorStoreFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VectorStore =============================

// ==========================  START: Project =============================

type Project struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     openai.ProjectDescription `json:"Description"`
	Metadata        openai.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type ProjectHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Project       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ProjectHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ProjectHit      `json:"hits"`
}

type ProjectSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  ProjectHits `json:"hits"`
}

type ProjectPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewProjectPaginator(filters []essdk.BoolFilter, limit *int64) (ProjectPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_project", filters, limit)
	if err != nil {
		return ProjectPaginator{}, err
	}

	p := ProjectPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ProjectPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ProjectPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ProjectPaginator) NextPage(ctx context.Context) ([]Project, error) {
	var response ProjectSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Project
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listProjectFilters = map[string]string{
	"id":     "Description.ID",
	"name":   "Description.Name",
	"object": "Description.Object",
	"status": "Description.Status",
}

func ListProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListProject")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, listProjectFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject NewProjectPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListProject paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getProjectFilters = map[string]string{
	"id":     "Description.ID",
	"name":   "Description.Name",
	"object": "Description.Object",
	"status": "Description.Status",
}

func GetProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetProject")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, getProjectFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Project =============================

// ==========================  START: ProjectUser =============================

type ProjectUser struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     openai.ProjectUserDescription `json:"Description"`
	Metadata        openai.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type ProjectUserHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ProjectUser   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ProjectUserHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ProjectUserHit  `json:"hits"`
}

type ProjectUserSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  ProjectUserHits `json:"hits"`
}

type ProjectUserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewProjectUserPaginator(filters []essdk.BoolFilter, limit *int64) (ProjectUserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_project_user", filters, limit)
	if err != nil {
		return ProjectUserPaginator{}, err
	}

	p := ProjectUserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ProjectUserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ProjectUserPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ProjectUserPaginator) NextPage(ctx context.Context) ([]ProjectUser, error) {
	var response ProjectUserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ProjectUser
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listProjectUserFilters = map[string]string{
	"project_id": "Description.ProjectID",
	"user_id":    "Description.UserID",
}

func ListProjectUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListProjectUser")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectUser NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectUser NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewProjectUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, listProjectUserFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectUser NewProjectUserPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListProjectUser paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getProjectUserFilters = map[string]string{
	"project_id": "Description.ProjectID",
	"user_id":    "Description.UserID",
}

func GetProjectUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetProjectUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewProjectUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, getProjectUserFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ProjectUser =============================

// ==========================  START: ProjectServiceAccount =============================

type ProjectServiceAccount struct {
	ResourceID      string                                  `json:"resource_id"`
	PlatformID      string                                  `json:"platform_id"`
	Description     openai.ProjectServiceAccountDescription `json:"Description"`
	Metadata        openai.Metadata                         `json:"metadata"`
	DescribedBy     string                                  `json:"described_by"`
	ResourceType    string                                  `json:"resource_type"`
	IntegrationType string                                  `json:"integration_type"`
	IntegrationID   string                                  `json:"integration_id"`
}

type ProjectServiceAccountHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ProjectServiceAccount `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ProjectServiceAccountHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ProjectServiceAccountHit `json:"hits"`
}

type ProjectServiceAccountSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ProjectServiceAccountHits `json:"hits"`
}

type ProjectServiceAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewProjectServiceAccountPaginator(filters []essdk.BoolFilter, limit *int64) (ProjectServiceAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_project_serviceaccount", filters, limit)
	if err != nil {
		return ProjectServiceAccountPaginator{}, err
	}

	p := ProjectServiceAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ProjectServiceAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ProjectServiceAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ProjectServiceAccountPaginator) NextPage(ctx context.Context) ([]ProjectServiceAccount, error) {
	var response ProjectServiceAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ProjectServiceAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listProjectServiceAccountFilters = map[string]string{
	"id":         "Description.ID",
	"name":       "Description.Name",
	"object":     "Description.Object",
	"project_id": "Description.ProjectID",
	"role":       "Description.Role",
}

func ListProjectServiceAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListProjectServiceAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectServiceAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectServiceAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectServiceAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectServiceAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectServiceAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewProjectServiceAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listProjectServiceAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectServiceAccount NewProjectServiceAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListProjectServiceAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getProjectServiceAccountFilters = map[string]string{
	"id":         "Description.ID",
	"name":       "Description.Name",
	"object":     "Description.Object",
	"project_id": "Description.ProjectID",
	"role":       "Description.Role",
}

func GetProjectServiceAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetProjectServiceAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewProjectServiceAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getProjectServiceAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ProjectServiceAccount =============================

// ==========================  START: ProjectApiKey =============================

type ProjectApiKey struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     openai.ProjectApiKeyDescription `json:"Description"`
	Metadata        openai.Metadata                 `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type ProjectApiKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ProjectApiKey `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ProjectApiKeyHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []ProjectApiKeyHit `json:"hits"`
}

type ProjectApiKeySearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  ProjectApiKeyHits `json:"hits"`
}

type ProjectApiKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewProjectApiKeyPaginator(filters []essdk.BoolFilter, limit *int64) (ProjectApiKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_project_apikey", filters, limit)
	if err != nil {
		return ProjectApiKeyPaginator{}, err
	}

	p := ProjectApiKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ProjectApiKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ProjectApiKeyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ProjectApiKeyPaginator) NextPage(ctx context.Context) ([]ProjectApiKey, error) {
	var response ProjectApiKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ProjectApiKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listProjectApiKeyFilters = map[string]string{
	"id":             "Description.ID",
	"name":           "Description.Name",
	"object":         "Description.Object",
	"owner":          "Description.Owner",
	"project_id":     "Description.ProjectID",
	"redacted_value": "Description.RedactedValue",
}

func ListProjectApiKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListProjectApiKey")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectApiKey NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectApiKey NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectApiKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectApiKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectApiKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewProjectApiKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listProjectApiKeyFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectApiKey NewProjectApiKeyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListProjectApiKey paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getProjectApiKeyFilters = map[string]string{
	"id":             "Description.ID",
	"name":           "Description.Name",
	"object":         "Description.Object",
	"owner":          "Description.Owner",
	"project_id":     "Description.ProjectID",
	"redacted_value": "Description.RedactedValue",
}

func GetProjectApiKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetProjectApiKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewProjectApiKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getProjectApiKeyFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ProjectApiKey =============================

// ==========================  START: ProjectRateLimit =============================

type ProjectRateLimit struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     openai.ProjectRateLimitDescription `json:"Description"`
	Metadata        openai.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type ProjectRateLimitHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ProjectRateLimit `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ProjectRateLimitHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ProjectRateLimitHit `json:"hits"`
}

type ProjectRateLimitSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ProjectRateLimitHits `json:"hits"`
}

type ProjectRateLimitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewProjectRateLimitPaginator(filters []essdk.BoolFilter, limit *int64) (ProjectRateLimitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "openai_project_ratelimit", filters, limit)
	if err != nil {
		return ProjectRateLimitPaginator{}, err
	}

	p := ProjectRateLimitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ProjectRateLimitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ProjectRateLimitPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ProjectRateLimitPaginator) NextPage(ctx context.Context) ([]ProjectRateLimit, error) {
	var response ProjectRateLimitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ProjectRateLimit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listProjectRateLimitFilters = map[string]string{
	"batch_1_day_max_input_tokens":     "Description.Batch1DayMaxInputTokens",
	"id":                               "Description.ID",
	"max_audio_megabytes_per_1_minute": "Description.MaxAudioMegabytesPer1Minute",
	"max_images_per_1_minute":          "Description.MaxImagesPer1Minute",
	"max_requests_per_1_day":           "Description.MaxRequestsPer1Day",
	"max_requests_per_1_minute":        "Description.MaxRequestsPer1Minute",
	"max_tokens_per_1_minute":          "Description.MaxTokensPer1Minute",
	"model":                            "Description.Model",
	"object":                           "Description.Object",
	"project_id":                       "Description.ProjectID",
}

func ListProjectRateLimit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListProjectRateLimit")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectRateLimit NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectRateLimit NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectRateLimit GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectRateLimit GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectRateLimit GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewProjectRateLimitPaginator(essdk.BuildFilter(ctx, d.QueryContext, listProjectRateLimitFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListProjectRateLimit NewProjectRateLimitPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListProjectRateLimit paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getProjectRateLimitFilters = map[string]string{
	"batch_1_day_max_input_tokens":     "Description.Batch1DayMaxInputTokens",
	"id":                               "Description.ID",
	"max_audio_megabytes_per_1_minute": "Description.MaxAudioMegabytesPer1Minute",
	"max_images_per_1_minute":          "Description.MaxImagesPer1Minute",
	"max_requests_per_1_day":           "Description.MaxRequestsPer1Day",
	"max_requests_per_1_minute":        "Description.MaxRequestsPer1Minute",
	"max_tokens_per_1_minute":          "Description.MaxTokensPer1Minute",
	"model":                            "Description.Model",
	"object":                           "Description.Object",
	"project_id":                       "Description.ProjectID",
}

func GetProjectRateLimit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetProjectRateLimit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewProjectRateLimitPaginator(essdk.BuildFilter(ctx, d.QueryContext, getProjectRateLimitFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ProjectRateLimit =============================
