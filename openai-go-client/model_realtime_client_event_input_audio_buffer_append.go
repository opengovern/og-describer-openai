/*
OpenAI API

The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.

API version: 2.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the RealtimeClientEventInputAudioBufferAppend type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &RealtimeClientEventInputAudioBufferAppend{}

// RealtimeClientEventInputAudioBufferAppend Send this event to append audio bytes to the input audio buffer. The audio buffer is temporary storage you can write to and later commit. In Server VAD mode, the audio buffer is used to detect speech and the server will decide when to commit. When Server VAD is disabled, you must commit the audio buffer manually. The client may choose how much audio to place in each event up to a maximum of 15 MiB, for example streaming smaller chunks from the client may allow the VAD to be more responsive. Unlike made other client events, the server will not send a confirmation response to this event.
type RealtimeClientEventInputAudioBufferAppend struct {
	// Optional client-generated ID used to identify this event.
	EventId *string `json:"event_id,omitempty"`
	// The event type, must be \"input_audio_buffer.append\".
	Type string `json:"type"`
	// Base64-encoded audio bytes. This must be in the format specified by the `input_audio_format` field in the session configuration.
	Audio string `json:"audio"`
}

type _RealtimeClientEventInputAudioBufferAppend RealtimeClientEventInputAudioBufferAppend

// NewRealtimeClientEventInputAudioBufferAppend instantiates a new RealtimeClientEventInputAudioBufferAppend object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRealtimeClientEventInputAudioBufferAppend(type_ string, audio string) *RealtimeClientEventInputAudioBufferAppend {
	this := RealtimeClientEventInputAudioBufferAppend{}
	this.Type = type_
	this.Audio = audio
	return &this
}

// NewRealtimeClientEventInputAudioBufferAppendWithDefaults instantiates a new RealtimeClientEventInputAudioBufferAppend object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRealtimeClientEventInputAudioBufferAppendWithDefaults() *RealtimeClientEventInputAudioBufferAppend {
	this := RealtimeClientEventInputAudioBufferAppend{}
	return &this
}

// GetEventId returns the EventId field value if set, zero value otherwise.
func (o *RealtimeClientEventInputAudioBufferAppend) GetEventId() string {
	if o == nil || IsNil(o.EventId) {
		var ret string
		return ret
	}
	return *o.EventId
}

// GetEventIdOk returns a tuple with the EventId field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RealtimeClientEventInputAudioBufferAppend) GetEventIdOk() (*string, bool) {
	if o == nil || IsNil(o.EventId) {
		return nil, false
	}
	return o.EventId, true
}

// HasEventId returns a boolean if a field has been set.
func (o *RealtimeClientEventInputAudioBufferAppend) HasEventId() bool {
	if o != nil && !IsNil(o.EventId) {
		return true
	}

	return false
}

// SetEventId gets a reference to the given string and assigns it to the EventId field.
func (o *RealtimeClientEventInputAudioBufferAppend) SetEventId(v string) {
	o.EventId = &v
}

// GetType returns the Type field value
func (o *RealtimeClientEventInputAudioBufferAppend) GetType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Type
}

// GetTypeOk returns a tuple with the Type field value
// and a boolean to check if the value has been set.
func (o *RealtimeClientEventInputAudioBufferAppend) GetTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Type, true
}

// SetType sets field value
func (o *RealtimeClientEventInputAudioBufferAppend) SetType(v string) {
	o.Type = v
}

// GetAudio returns the Audio field value
func (o *RealtimeClientEventInputAudioBufferAppend) GetAudio() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Audio
}

// GetAudioOk returns a tuple with the Audio field value
// and a boolean to check if the value has been set.
func (o *RealtimeClientEventInputAudioBufferAppend) GetAudioOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Audio, true
}

// SetAudio sets field value
func (o *RealtimeClientEventInputAudioBufferAppend) SetAudio(v string) {
	o.Audio = v
}

func (o RealtimeClientEventInputAudioBufferAppend) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o RealtimeClientEventInputAudioBufferAppend) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.EventId) {
		toSerialize["event_id"] = o.EventId
	}
	toSerialize["type"] = o.Type
	toSerialize["audio"] = o.Audio
	return toSerialize, nil
}

func (o *RealtimeClientEventInputAudioBufferAppend) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"type",
		"audio",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varRealtimeClientEventInputAudioBufferAppend := _RealtimeClientEventInputAudioBufferAppend{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varRealtimeClientEventInputAudioBufferAppend)

	if err != nil {
		return err
	}

	*o = RealtimeClientEventInputAudioBufferAppend(varRealtimeClientEventInputAudioBufferAppend)

	return err
}

type NullableRealtimeClientEventInputAudioBufferAppend struct {
	value *RealtimeClientEventInputAudioBufferAppend
	isSet bool
}

func (v NullableRealtimeClientEventInputAudioBufferAppend) Get() *RealtimeClientEventInputAudioBufferAppend {
	return v.value
}

func (v *NullableRealtimeClientEventInputAudioBufferAppend) Set(val *RealtimeClientEventInputAudioBufferAppend) {
	v.value = val
	v.isSet = true
}

func (v NullableRealtimeClientEventInputAudioBufferAppend) IsSet() bool {
	return v.isSet
}

func (v *NullableRealtimeClientEventInputAudioBufferAppend) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRealtimeClientEventInputAudioBufferAppend(val *RealtimeClientEventInputAudioBufferAppend) *NullableRealtimeClientEventInputAudioBufferAppend {
	return &NullableRealtimeClientEventInputAudioBufferAppend{value: val, isSet: true}
}

func (v NullableRealtimeClientEventInputAudioBufferAppend) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRealtimeClientEventInputAudioBufferAppend) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


